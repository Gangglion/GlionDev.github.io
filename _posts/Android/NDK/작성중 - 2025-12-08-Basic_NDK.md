---
title: "NDK 와 JNI 기본"
date: 2025-12-08 14:47:24 +0900
categories: [Android, NDK]
tags: [Android, NDK, JNI, C++, Native Development Kit, Java Native Interface]
---

## NDK 란
**N**ative **D**evelopment **K**it 의 약자로서, Android 앱 개발 시 Java/Kotlin 코드와 상호작용 할 수 있도록 C/C++ 라이브러리를 지원하는 툴킷이다.

주로 고성능 그래픽처리나 오디오 신호 처리 등 **JVM 보다 빠른 연산 속도가 필요한 작업**에 활용된다.

C/C++ 코드를 사용하여 무거운 연산의 성능 최적화뿐만 아니라 FFmpeg, OpenCV 등 레거시 C/C++ 라이브러리를 안드로이드 앱에 이식할때 필수적으로 사용된다.

## JNI 란
**J**ava **N**ative **I**nterface 의 약자로서, Java/Kotlin 코드와 NDK로 작성된 C/C++ 코드가 서로 통신할 수 있도록 연결해 주는 인터페이스 이다.

두 언어 환경 사이에 브릿지 역할을 하여, Java/Kotlin 에서 Nativa 함수를 호출하여 결과를 받거나, 반대로 Native 코드에서 Java 객체를 제어할 수 있게 해준다.

서로 다른 메모리 구조를 가진 두 언어를 연결하기 때문에, **데이터를 변환하고 전달하는 과정(마샬링)에서 오버헤드가 발생**한다. 따라서 너무 **빈번하게 JNI 를 호출하는 것은 오히려 성능을 저하**시킬 수 있다.

## 프로젝트 구조
전체 구조도

Android Studio 의 Project View 를 Project 로 전환했을떄 아래의 구조가 된다
```
app(Module)
    main
     ├─ cpp
     │   ├─ include(외부 라이브러리를 사용하는 경우 별도 생성)
     │   ├─ CMakeLists.txt
     │   └─ native-lib.cpp
     ├─ java
     │   └─ com
     │       └─ example
     │           └─ sample
     │               ├─ MainActivity
     │               └─ JniBridge.kt(별도 생성)
     └─ JniLibs(외부 라이브러리를 사용하는 경우 아키텍처 별 하위 폴더까지 별도 생성)
            ├─ arm6-v8a
            └─ armeabi-v7a
```

### 실행 원리
네이티브 코드가 포함된 프로젝트가 빌드될 때는 아래와 같은 순서를 거친다.
1. 전체 프로젝트 빌드는 `Gradle` 이 수행한다.
2. 빌드 중 `Gradle` 은 프로젝트 내에 네이티브 소스의 빌드가 필요함을 감지한다.
3. `CMake` 가 호출되고, `CMakeLists.txt` 를 읽고 분석한다.
4. 분석된 내용(소스코드 위치, 라이브러리 이름 등) 을 바탕으로 컴파일러(`Clang` 등) 에게 명령을 내려 실제 소스코드를 컴파일하고 링킹한다.
5. 그 결과로, 라이브러리 이름의 `.so` 파일이 생성된다.
6. Gradle 은 앞서 컴파일된 Java 바이너리(`.dex`) 와 Native 바이너리(`.so`) 를 합쳐 하나의 `.apk` 로 만든다.
7. 실제 앱이 실행될때, JNI 를 통해 네이티브 기능에 접근하는 시점에 `.so` 파일을 메모리에 올리고 특정 기능을 수행한다.

### 1. 새로운 프로젝트를 만들 경우(Android Studio )
1. File -> New Project  
2. Native C++ 선택
    ![프로젝트 생성 - 1](https://host.ggoggo.duckdns.org/Blog/251208_ndk/new_project_1.png)
3. 프로젝트명, 패키지명, 저장위치, 언어(Java/Kotlin), Minimum SDK, Build configuration language 는 기존 프로젝트 생성할때와 동일하게 작성한다.
    ![프로젝트 생성 - 2](https://host.ggoggo.duckdns.org/Blog/251208_ndk/new_project_2.png)
4. C++ 버전을 선택한다. 선택하지 않으면 **C++ 의 지원되는 기능은 NDK 버전에 따라 달라**진다.
    ![프로젝트 생성 - 3](https://host.ggoggo.duckdns.org/Blog/251208_ndk/new_project_3.png)
### 2. 기존 프로젝트에 NDK 를 통합하는 경우
1. Project View 를 Android 에서 Project 로 변경한다.
2. SDK Manager -> SDK Tools 에서 `NDK(Side by side)` 와 `CMake` 를 설치한다. 혹 버전을 선택하여 설치하고 싶다면, 하위의 `Show Package Details` 를 체크하여 원하는 버전을 선택하여 설치한다.
3. main 하위에 new -> Directory `cpp` 를 생성한다.
4. cpp 폴더 하위에 new -> CMakeLists.txt 를 추가한다.
5. cpp 폴더 하위에 new -> C/C++ Source File 을 추가한다. 해당 파일은 JNI 를 통해 통신할 기본적인 cpp 파일이다.
6. 3에서 추가한 `CMakeLists.txt` 에 아래 내용을 기입한다. 각 부분별 설명은 아래에서 자세히 다룬다.
    ```CMake
    # 개발환경에 설치된 CMake 버전을 명시한다.
    cmake_minimum_required(VERSION 3.22.1) 

    # 프로젝트 명을 기재
    project("myapplication")

    # 생성할 라이브러리의 이름. 예를 들어 ndk-test 로 지정하면 빌드 시 libnek-test.so 파일이 빌드된다.
    add_library(library-name SHARED
        # 생성할 라이브러리에 포함될 cpp 파일을 기재한다. 기본적으로 5 에서 추가한 cpp 를 넣어주어야 한다.
        native-lib.cpp)
    
    # 실행파일이 의존하는 다른 라이브러리를 연결한다. 기본적으로 `android` 는 Native 레벨에서 Android OS 의 리소스에 접근하는데 사용되고, `log` 는 Native 코드 레벨에서 로그캣에 출력되는 로그를 사용하기 위함이다.
    target_link_libraries(library-name
        android
        log)
    ```
7. build.gradle(:app) 에서 아래 내용을 추가한다.
    ```kotlin
    externalNativeBuild {
        cmake {
            path = file("src/main/cpp/CMakeLists.txt") // CMakeLists.txt 파일이 위치한 경로
            version = "3.22.1" // CMake 버전
        }
    }
    ```
## CMakeLists.txt
`CMakeLists.txt` 파일은 네이티브 코드(C/C++) 를 빌드하는 빌드 시스템 `CMake` 를 위한 입력 파일이다. Android 프로젝트를 `gradle` 을 통해서 빌드할때 설정을 `build.gradle` 에 기재하는것과 동일한 역할을 한다.

아래에 작성되는 설정을 CMake 에 알려준다.
- C/C++ 컴파일러
- 소스파일
- 라이브러리 종속성
- 빌드 옵션
- 등등

### cmake_minimum_required(VERSION x.x.x)
CMake 를 실행하는데 필요한 최소 버전 정의
```CMake
cmake_minimum_required(VERSION 3.22.1)
```
### project("project_name")
프로젝트의 이름 정의. Android 프로젝트 이름과 달라도 상관없지만, 같게 맞추는게 좋음
```CMake
project("my_native_app")
```
### set

### add_library(\<name> \<type> [source files] ... )
소스파일 및 라이브러리 추가(C/C++ 소스파일 컴파일 -> 라이브러리 생성)
- **name** : 생성할 라이브러리의 이름. 추후 Jni Kotlin 코드에서 `System.loadLibrary` 에서 사용되는 이름. 최종 출력 파일의 이름 앞에 `lib` 가 붙는다.
- **type** : 라이브러리 유형 지정
  - **SHARED** : 동적 링크 라이브러리(.so). NDK 에서 주로 사용한다.
  - **STATIC** : 정적 링크 라이브러리(.a). 다른 라이브러리에 링크되어 최종 so 에 포함된다. 반드시 어딘가에 링크되어야 한다. .so 처럼 독립적으로 로드가 불가능하다.
  - **OBJECT** : 목적파일(.o) 만 생성한다. 특수한 상황에서만 사용한다.
- **source files** : 빌드할 소스파일 목록이다. 생성한 모든 cpp 파일을 여기에 전부 명시해야 한다.

### find_package(\<package_name> [version] [REQUIRED] [COMPONENTS])
종속 라이브러리 찾기

CMake 가 시스템 경로나 지정된 경로에 이미 존재하는 라이브러리나 모듈을 찾아 로드한다.
> Gradle(implementation) 처럼 라이브러리를 인터넷에서 다운로드 & 설치해주는 명령어가 아님. 이미 컴퓨터나 프로젝트 내에 설치된(존재하는) 라이브러리의 위치를 찾아 연결해주는 역할을 한다.
{: .prompt-warning }

- **package_name** : 찾고자 하는 라이브러리/모듈 이름(대소문자 구분함)
- **REQUIRED** : 라이브러리를 찾지 못하면 경고에서 그치지 않고, **빌드 자체를 실패(에러)**로 처리한다. 필수 라이브러리일때 사용한다.
- **CONFIG** : CMake 내장 검색 방식("Find 모듈")을 건너뛰고, 라이브러리 제작자가 제공하거나 빌드 시스템이 생성한 "설정 파일(`*Config.cmake`)" 을 우선적으로 찾도록 강제한다.

> Android Gradle 에서 prefab 을 지원하는 라이브러리(예 : Oboe) 를 implementation 하면, Gradle 이 다운로드한 AAR 내부에 CMake 를 위한 설정 파일이 자동 생성된다. 이를 CMake 에서 인식하기 위해 아래와 같이 사용된다.
> ```CMake
> find_package(oboe REQUIRED CONFIG)
> ```
{: .prompt-tip }

### 

## JNI 구성

## 사용 예시

## MVVM Pattern(Clean Architecture) 관점